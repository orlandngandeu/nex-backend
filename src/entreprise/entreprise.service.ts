import {
  Injectable,
  NotFoundException,
  BadRequestException,
  ForbiddenException,
} from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository, IsNull, Not } from 'typeorm';
import { Entreprise } from './entities/entreprise.entity';
import { Utilisateur } from '../User/entities/utilisateur.entity';
import { UtilisateurEntreprise } from '../UtilisateurEntreprise/entities/utilisateur-entreprise.entity';
import { CreateEntrepriseDto } from './dto/create-entreprise.dto';
import { UpdateEntrepriseDto } from './dto/update-entreprise.dto';
import { InviteUserDto } from './dto/invite-user.dto';
import { TransferOwnershipDto } from './dto/transfer-ownership.dto';
import { PaginationDto } from './dto/pagination.dto';
import { Role } from '../utils/enums/enums';
import * as PDFDocument from 'pdfkit';
import { v4 as uuidv4 } from 'uuid';
import { TwilioService } from 'src/twillio/twillio.service';


@Injectable()
export class EntrepriseService {
  constructor(
    @InjectRepository(Entreprise)
    private entrepriseRepository: Repository<Entreprise>,
    @InjectRepository(Utilisateur)
    private utilisateurRepository: Repository<Utilisateur>,
    @InjectRepository(UtilisateurEntreprise)
    private utilisateurEntrepriseRepository: Repository<UtilisateurEntreprise>,
     private twilioService: TwilioService,
  ) {}

async createEntreprise(createEntrepriseDto: CreateEntrepriseDto, adminId: string) {
  // V√©rifier que l'utilisateur existe et est un admin
  const admin = await this.utilisateurRepository.findOne({
    where: { idUtilisateur: adminId, role: Role.ADMIN },
  });
  if (!admin) {
    throw new NotFoundException('Administrateur introuvable');
  }

  // Cr√©er l'entreprise
  const entreprise = this.entrepriseRepository.create({
    nom: createEntrepriseDto.nom,
    domaine: createEntrepriseDto.domaine,
    adresse: createEntrepriseDto.adresse,
    email: createEntrepriseDto.email,
    nbre_employers: createEntrepriseDto.nbre_employers,
  });
  
  const savedEntreprise = await this.entrepriseRepository.save(entreprise);

  // Associer l'admin cr√©ateur comme g√©rant de l'entreprise
  const utilisateurEntreprise = this.utilisateurEntrepriseRepository.create({
    utilisateur: admin,
    entreprise: savedEntreprise,
    isOwner: true,
  });
  
  await this.utilisateurEntrepriseRepository.save(utilisateurEntreprise);

  return {
    message: 'Entreprise cr√©√©e avec succ√®s',
    entreprise: savedEntreprise,
    gerant: admin.nom,
  };
}

async assignManager(
  entrepriseId: string, 
  newManagerId: string, 
  currentUserId: string,
  currentUserRole: Role
) {
  // V√©rifier que l'entreprise existe
  const entreprise = await this.entrepriseRepository.findOne({
    where: { idEntreprise: entrepriseId },
  });
  if (!entreprise) {
    throw new NotFoundException('Entreprise introuvable');
  }

  // V√©rifier que le nouveau g√©rant existe et a le bon r√¥le
  const newManager = await this.utilisateurRepository.findOne({
    where: { 
      idUtilisateur: newManagerId, 
      role: Role.MANAGER 
    },
  });
  if (!newManager) {
    throw new NotFoundException('Nouveau g√©rant introuvable ou r√¥le invalide');
  }

  // Si l'utilisateur actuel n'est pas admin, v√©rifier qu'il est le g√©rant actuel
  if (currentUserRole !== Role.ADMIN) {
    const currentManagerAssociation = await this.utilisateurEntrepriseRepository.findOne({
      where: {
        utilisateur: { idUtilisateur: currentUserId },
        entreprise: { idEntreprise: entrepriseId },
        isOwner: true,
      },
    });
    
    if (!currentManagerAssociation) {
      throw new ForbiddenException('Vous n\'√™tes pas autoris√© √† modifier le g√©rant de cette entreprise');
    }
  }

  // Retirer le statut de g√©rant √† l'ancien g√©rant
  await this.utilisateurEntrepriseRepository.update(
    { 
      entreprise: { idEntreprise: entrepriseId },
      isOwner: true 
    },
    { isOwner: false }
  );

  // V√©rifier si le nouveau g√©rant est d√©j√† associ√© √† l'entreprise
  let managerAssociation = await this.utilisateurEntrepriseRepository.findOne({
    where: {
      utilisateur: { idUtilisateur: newManagerId },
      entreprise: { idEntreprise: entrepriseId },
    },
  });

  if (managerAssociation) {
    // Mettre √† jour l'association existante
    managerAssociation.isOwner = true;
    await this.utilisateurEntrepriseRepository.save(managerAssociation);
  } else {
    // Cr√©er une nouvelle association
    managerAssociation = this.utilisateurEntrepriseRepository.create({
      utilisateur: newManager,
      entreprise: entreprise,
      isOwner: true,
    });
    await this.utilisateurEntrepriseRepository.save(managerAssociation);
  }

  return {
    message: 'G√©rant affect√© avec succ√®s',
    entreprise: entreprise.nom,
    nouveauGerant: newManager.nom,
  };
}

  async findAll(paginationDto: PaginationDto) {
    const { page = 1, limit = 10 } = paginationDto;
    const skip = (page - 1) * limit;

    const [entreprises, total] = await this.entrepriseRepository.findAndCount({
      where: { delete_at: IsNull() },
      relations: ['utilisateurs', 'utilisateurs.utilisateur'],
      skip,
      take: limit,
      order: { dateCreation: 'DESC' },
    });

    return {
      data: entreprises,
      meta: {
        total,
        page,
        limit,
        totalPages: Math.ceil(total / limit),
      },
    };
  }

  async findAllDeleted(paginationDto: PaginationDto) {
    const { page = 1, limit = 10 } = paginationDto;
    const skip = (page - 1) * limit;

    const [entreprises, total] = await this.entrepriseRepository.findAndCount({
      where: { delete_at: Not(IsNull()) },
      withDeleted: true,
      relations: ['utilisateurs', 'utilisateurs.utilisateur'],
      skip,
      take: limit,
      order: { delete_at: 'DESC' },
    });

    return {
      data: entreprises,
      meta: {
        total,
        page,
        limit,
        totalPages: Math.ceil(total / limit),
      },
    };
  }

  async findOne(id: string) {
    const entreprise = await this.entrepriseRepository.findOne({
      where: { idEntreprise: id, delete_at: IsNull() },
      relations: ['utilisateurs', 'utilisateurs.utilisateur'],
    });

    if (!entreprise) {
      throw new NotFoundException('Entreprise introuvable');
    }

    return entreprise;
  }

  async getUsersByEntreprise(id: string, paginationDto: PaginationDto) {
    const { page = 1, limit = 10 } = paginationDto;
    const skip = (page - 1) * limit;

    const entreprise = await this.findOne(id);

    const [utilisateurs, total] = await this.utilisateurEntrepriseRepository.findAndCount({
      where: { entreprise: { idEntreprise: id } },
      relations: ['utilisateur'],
      skip,
      take: limit,
      order: { dateAjout: 'DESC' },
    });

    return {
      entreprise: entreprise.nom,
      data: utilisateurs,
      meta: {
        total,
        page,
        limit,
        totalPages: Math.ceil(total / limit),
      },
    };
  }

  async update(id: string, updateEntrepriseDto: UpdateEntrepriseDto, userId: string) {
    const entreprise = await this.findOne(id);

    // V√©rifier les permissions
    await this.checkUserPermissions(id, userId);

    Object.assign(entreprise, updateEntrepriseDto);
    const updatedEntreprise = await this.entrepriseRepository.save(entreprise);

    return {
      message: 'Entreprise mise √† jour avec succ√®s',
      entreprise: updatedEntreprise,
    };
  }

// Dans votre service d'entreprise
async inviteUser(id: string, inviteUserDto: InviteUserDto, inviterId: string) {
  const entreprise = await this.findOne(id);
 
  // V√©rifier les permissions
  await this.checkUserPermissions(id, inviterId);
  
  // V√©rifier que l'utilisateur existe
  const user = await this.utilisateurRepository.findOne({
    where: { idUtilisateur: inviteUserDto.userId },
  });
  if (!user) {
    throw new NotFoundException('Utilisateur introuvable');
  }
  
  // V√©rifier si l'utilisateur n'est pas d√©j√† dans l'entreprise
  const existingRelation = await this.utilisateurEntrepriseRepository.findOne({
    where: {
      utilisateur: { idUtilisateur: inviteUserDto.userId },
      entreprise: { idEntreprise: id },
    },
  });
  if (existingRelation) {
    throw new BadRequestException('Utilisateur d√©j√† membre de cette entreprise');
  }
  
  // L'utilisateur a d√©j√† un compte avec ses identifiants
  
  // Cr√©er la relation
  const utilisateurEntreprise = this.utilisateurEntrepriseRepository.create({
    utilisateur: user,
    entreprise,
    isOwner: false,
  });
  await this.utilisateurEntrepriseRepository.save(utilisateurEntreprise);
  
  // Pr√©parer le message SMS avec les identifiants existants
  const messageSMS = `
üéâ F√©licitations ${user.nom} !

Vous avez √©t√© invit√©(e) √† rejoindre l'entreprise "${entreprise.nom}".

Vos identifiants de connexion :
üì± T√©l√©phone : ${user.telephone}
üîê Mot de passe : ${user.motDePasse}

Connectez-vous d√®s maintenant pour acc√©der √† votre nouvelle entreprise.

Bienvenue dans l'√©quipe ! üöÄ
  `.trim();
  
  // Envoyer le SMS
  try {
    await this.twilioService.sendSMS(user.telephone, messageSMS);
  } catch (error) {
    // Log l'erreur mais ne pas faire √©chouer l'invitation
    console.error('Erreur lors de l\'envoi du SMS:', error);
    // Optionnel: vous pourriez vouloir supprimer la relation cr√©√©e si le SMS √©choue
  }
  
  return {
    message: 'Utilisateur invit√© avec succ√®s et SMS envoy√©',
    user: user.nom,
    entreprise: entreprise.nom,
    smsEnvoye: true
  };
}

// M√©thodes utilitaires pour le service SMS (optionnelles)
generateVerificationCode(): string {
  return Math.floor(100000 + Math.random() * 900000).toString();
}
  async transferOwnership(
    id: string,
    transferOwnershipDto: TransferOwnershipDto,
    currentOwnerId: string,
  ) {
    const entreprise = await this.findOne(id);

    // V√©rifier que l'utilisateur actuel est le propri√©taire
    const currentOwnerRelation = await this.utilisateurEntrepriseRepository.findOne({
      where: {
        utilisateur: { idUtilisateur: currentOwnerId },
        entreprise: { idEntreprise: id },
        isOwner: true,
      },
    });

    if (!currentOwnerRelation) {
      throw new ForbiddenException('Seul le propri√©taire peut transf√©rer la propri√©t√©');
    }

    // V√©rifier que le nouveau propri√©taire existe et est membre de l'entreprise
    const newOwnerRelation = await this.utilisateurEntrepriseRepository.findOne({
      where: {
        utilisateur: { idUtilisateur: transferOwnershipDto.newOwnerId },
        entreprise: { idEntreprise: id },
      },
      relations: ['utilisateur'],
    });

    if (!newOwnerRelation) {
      throw new NotFoundException('Nouveau propri√©taire introuvable dans cette entreprise');
    }

    // Transf√©rer la propri√©t√©
    currentOwnerRelation.isOwner = false;
    newOwnerRelation.isOwner = true;

    await this.utilisateurEntrepriseRepository.save([currentOwnerRelation, newOwnerRelation]);

    return {
      message: 'Propri√©t√© transf√©r√©e avec succ√®s',
      newOwner: newOwnerRelation.utilisateur.nom,
      entreprise: entreprise.nom,
    };
  }

  async exportToCSV(id: string): Promise<string> {
    const entreprise = await this.findOne(id);
    const utilisateurs = await this.getUsersByEntreprise(id, { page: 1, limit: 1000 });

    let csvContent = 'Nom,Email,T√©l√©phone,R√¥le,Propri√©taire,Date d\'ajout\n';
    
    utilisateurs.data.forEach((ue) => {
      const user = ue.utilisateur;
      csvContent += `"${user.nom}","${user.email}","${user.telephone}","${user.role}","${ue.isOwner ? 'Oui' : 'Non'}","${ue.dateAjout}"\n`;
    });

    return csvContent;
  }

  async exportToPDF(id: string): Promise<Buffer> {
    const entreprise = await this.findOne(id);
    const utilisateurs = await this.getUsersByEntreprise(id, { page: 1, limit: 1000 });

    return new Promise((resolve) => {
      const doc = new PDFDocument();
      const buffers: any[] = [];

      doc.on('data', buffers.push.bind(buffers));
      doc.on('end', () => {
        const pdfData = Buffer.concat(buffers);
        resolve(pdfData);
      });

      // En-t√™te
      doc.fontSize(20).text(`Entreprise: ${entreprise.nom}`, 100, 100);
      doc.fontSize(12).text(`Domaine: ${entreprise.domaine}`, 100, 130);
      doc.text(`Adresse: ${entreprise.adresse}`, 100, 150);
      doc.text(`Email: ${entreprise.email}`, 100, 170);
      doc.text(`Nombre d'employ√©s: ${entreprise.nbre_employers}`, 100, 190);

      // Liste des utilisateurs
      doc.fontSize(16).text('Utilisateurs:', 100, 230);
      let yPosition = 260;

      utilisateurs.data.forEach((ue) => {
        const user = ue.utilisateur;
        doc.fontSize(10).text(
          `${user.nom} - ${user.email} - ${user.role} - ${ue.isOwner ? 'Propri√©taire' : 'Membre'}`,
          100,
          yPosition,
        );
        yPosition += 20;
      });

      doc.end();
    });
  }

  async remove(id: string, userId: string) {
    const entreprise = await this.findOne(id);

    // V√©rifier les permissions
    await this.checkUserPermissions(id, userId);

    // Soft delete
    entreprise.delete_at = new Date();
    await this.entrepriseRepository.save(entreprise);

    return {
      message: 'Entreprise supprim√©e avec succ√®s',
      entreprise: entreprise.nom,
    };
  }

  async restore(id: string) {
    const entreprise = await this.entrepriseRepository.findOne({
      where: { idEntreprise: id },
      withDeleted: true,
    });

    if (!entreprise) {
      throw new NotFoundException('Entreprise introuvable');
    }

    if (!entreprise.delete_at) {
      throw new BadRequestException('Cette entreprise n\'est pas supprim√©e');
    }

    entreprise.delete_at = null;
    await this.entrepriseRepository.save(entreprise);

    return {
      message: 'Entreprise restaur√©e avec succ√®s',
      entreprise: entreprise.nom,
    };
  }

  private async checkUserPermissions(entrepriseId: string, userId: string) {
    const user = await this.utilisateurRepository.findOne({
      where: { idUtilisateur: userId },
    });

    if (!user) {
      throw new NotFoundException('Utilisateur introuvable');
    }

    // Admin peut tout faire
    if (user.role === Role.ADMIN) {
      return;
    }

    // V√©rifier si l'utilisateur est propri√©taire de l'entreprise
    const userEntreprise = await this.utilisateurEntrepriseRepository.findOne({
      where: {
        utilisateur: { idUtilisateur: userId },
        entreprise: { idEntreprise: entrepriseId },
        isOwner: true,
      },
    });

    if (!userEntreprise) {
      throw new ForbiddenException('Acc√®s refus√©: permissions insuffisantes');
    }
  }
}